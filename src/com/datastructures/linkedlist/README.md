## 链表

- SingleLinkedList : 单链表

- 测试题

  -  求单链表中有效节点的个数  getLength
  -  查找单链表中的倒数第 k 个节点  findLastIndexNode
  -  单链表的反转 
    ```
  思路:
  1. 先定义一个节点 reverseHead = new HeroNode();
  2. 从头到尾遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表的最前端
  3. 原来的链表的 head.next = reverseHead.next
    ```
  -  从尾到头打印单链表
  ```
  思路:
   1.上面的题的要求就是逆序打印单链表
   2. 方式1: 现将单链表进行反转操作,然后再遍历即可,这样的做的问题就是会破坏原来的单链表的结构,不建议
   2. 方式2: 可以利用栈这个数据结构,将各个节点压入 栈 中, 然后利用栈的 先进后出 的特点,就实现了逆序打印的效果
  ```
  -  合并两个有序的单链表,合并之后的链表依然有序
  ```
  思路:
   类似于反转链表,按照顺序创建新的链表,发现两个链表中哪个更小就加入新的链表中
  ```

- DoubleLinkedList : 双向链表

- 环形单向链表: CircleSingleLinkedList
    ```
    Josephu(约瑟夫)问题描述
        设编号为 1,2,...n 的 n 个人围坐一圈,约定编号为 k(1<=k<=n)的人从 1 开始报数,数到 m 的那个人出列,它的下一位又从 1 开始报数,数到 m 的那个人又出列,以此类推,知道所有人出列位置,由此产生一个出队编号的序列
     构建:
       1. 先创建第一个节点,让 first 指向该节点,并形成环
       2. 后面当我们没创建一个新的节点,就把该节点加入到已有的环形链表中即可
    
    
     遍历环形链表:
       1. 先让一个辅助指针(变量)curBoy,指向 first 节点
       2. 然后通过一个 while 循环遍历该环形链表即可, curBoy.next == first 结束
  
     根据用户的输入,生成一个小孩出圈的顺序
       1. 需求创建一个辅助指针(变量)helper,事先应该指向环形链表的最后这个节点
       补充: 小孩报数前,先让 first 和 helper 移动 (k - 1)次
       2. 当小孩报数时,让 first 和 helper 指针同时移动 (m-1) 次
       3. 这时就可以将 first 指向的小孩节点出圈
           first = first.next
           helper.next = first
       原来 first 指向的节点没有任何引用,就会被回收
    ```