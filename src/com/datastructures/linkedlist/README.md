## 链表

- SingleLinkedList : 单链表

- 测试题

  -  求单链表中有效节点的个数  getLength
  -  查找单链表中的倒数第 k 个节点  findLastIndexNode
  -  单链表的反转 
    ```
  思路:
  1. 先定义一个节点 reverseHead = new HeroNode();
  2. 从头到尾遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表的最前端
  3. 原来的链表的 head.next = reverseHead.next
    ```
  -  从尾到头打印单链表
  ```
  思路:
   1.上面的题的要求就是逆序打印单链表
   2. 方式1: 现将单链表进行反转操作,然后再遍历即可,这样的做的问题就是会破坏原来的单链表的结构,不建议
   2. 方式2: 可以利用栈这个数据结构,将各个节点压入 栈 中, 然后利用栈的 先进后出 的特点,就实现了逆序打印的效果
  ```
  -  合并两个有序的单链表,合并之后的链表依然有序
  ```
  思路:
   类似于反转链表,按照顺序创建新的链表,发现两个链表中哪个更小就加入新的链表中
  ```

- DoubleLinkedList : 双向链表

- 环形单向链表: CircleSingleLinkedList
```
思路:
构建:
1. 先创建第一个节点,让 first 指向该节点,并形成环
2. 后面当我们没创建一个新的节点,就把该节点加入到已有的环形链表中即可

Josephu 问题:
 遍历环形链表:
  1. 先让一个辅助指针(变量)curBoy,指向 first 节点
  2. 然后通过一个 while 循环遍历该环形链表即可, curBoy.next == first 结束

```